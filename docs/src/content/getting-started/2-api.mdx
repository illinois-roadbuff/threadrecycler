import { Callout } from 'nextra/components'

## Important: Manually recycling vs. automatically recycling
### Automatically recycling
```lua copy filename="some-script.lua"
ThreadPool.spawn(ThreadPool, function(thread, ...)
    print("Thread executed")
end)
```
```lua copy filename="some-script.lua"
local function foo(thread, ...)
    print("foo")
end)
ThreadPool.spawn(ThreadPool, foo, ...)
```

### Manually recycling
The accompanying function **MUST HAVE** a thread parameter whether you're recycling or not. 
```lua copy filename="some-script.lua"
ThreadPool.spawn(ThreadPool, function(thread, ...)
    print("Thread executed")
    ThreadPool.recycle(ThreadPool, thread) -- once you are finished
end)
```
```lua copy filename="some-script.lua"
local function foo(thread, ...)
    ThreadPool.recycle(ThreadPool, thread)
end)
ThreadPool.spawn(ThreadPool, foo, ...)
```

<Callout type="warning">
    Manually recycling is not required for the thread to recycle correctly! Don't use it unless you're confident that callback(...) or the funtion that you're providing will yield (or pause) the script entirely.
</Callout>


## API Reference

### `ThreadRecycler.new(ThreadCount, ThreadLifetime)`
Creates a `ThreadPool`.
```lua copy filename="some-script.lua"
local ThreadPool = ThreadRecycler.new(10, 60) -- function(index: number) if use signal == true
```

### `ThreadPool.wrap(ThreadPool, ManualRecycle: boolean, callback: function, ...: any)`
Creates and runs a thread using `coroutine.create()` and `coroutine.resume()`. If `ManualRecycle` is true, the function must have an index.
```lua copy filename="some-script.lua"
ThreadPool.wrap(ThreadPool, function(thread) -- function(index: number) if use signal == true
    print("Thread executed")
end)
```

### `ThreadPool.spawn(ThreadPool, ManualRecycle: boolean, callback: function, ...: any)`
Creates and runs a thread immediately using `task.spawn()`. If `ManualRecycle` is true, the function must have an index.
```lua copy filename="some-script.lua"
ThreadPool.spawn(ThreadPool, function(thread) -- function(index: number) if use signal == true
    print("Thread executed")
end)
```

### `ThreadPool.defer(ThreadPool, ManualRecycle: boolean, callback: function, ...: any)`
Executes a function on the next `RunService.Heartbeat`.
```lua copy filename="some-script.lua"
ThreadPool.defer(ThreadPool, function(thread)
    print("Deferred execution")
end)
```

### `ThreadPool.gooddefer(ThreadPool, ManualRecycle: boolean, callback: function, ...: any)`
Executes a function on the next `RunService.Heartbeat`. Works the same way as `ThreadRecycler.defer`, but doesn't have a function overhead.
```lua copy filename="some-script.lua"
ThreadPool.gooddefer(ThreadPool, function(thread)
    print("Executed on Heartbeat")
end)
```

### `ThreadPool.unsafedefer(ThreadPool, ManualRecycle: boolean, callback: function, ...: any)`
Uses `task.defer()` to execute the function at the end of the current execution cycle.
```lua copy filename="some-script.lua"
ThreadPool.unsafedefer(ThreadPool, function()
    print("Unsafe defer execution")
end)
```
<Callout type="error">
    It's STRONGLY recommended if you refrain from using this function; may lead to warnings and issues in the task library. (e.g. task.defer should not be called on a thread that is already 'deferred' in the task library)
</Callout>

### `ThreadPool.unsafedelay(ThreadPool, ManualRecycle: boolean, time: number, callback: function, ...: any)`
Uses `task.delay()` to execute the function after some time has been elapsed.
```lua copy filename="some-script.lua"
ThreadPool.unsafedelay(1, ThreadPool, function(thread)
    print("Unsafe delay execution")
end)
```
<Callout type="error">
    It's STRONGLY recommended if you refrain from using this function; may lead to warnings and issues in the task library. (e.g. task.delay should not be called on a thread that is already 'waiting' in the task library)
</Callout>

### `ThreadPool.delay(ThreadPool, ManualRecycle: boolean, time: number, callback: function, ...: any)`
Uses `ThreadRecycler.wait()` to execute the function after some time has been elapsed.
```lua copy filename="some-script.lua"
ThreadPool.delay(ThreadPool, 1, function(thread)
    print("Defer execution")
end)
```

### `ThreadPool.wait(seconds: number | nil)`
Pauses execution for a set duration using `os.clock()`.
```lua copy filename="some-script.lua"
ThreadPool.wait(2) -- Waits for 2 seconds
```
<Callout type="info">
    This function replaces `task.wait()`.
</Callout>

### `ThreadPool.recycle(ThreadPool, thread)`
Recycles a thread back into the pool.
```lua copy filename="some-script.lua"
ThreadRecycler.recycle(thread) -- Recycle thread 
```

### `ThreadPool.getstat(ThreadPool, stat: string) -> boolean, number | string`
Retrieves statistics about thread usage. Works on Count, Recycled, and Created.
```lua copy filename="some-script.lua"
local success, count = ThreadPool.getstat(ThreadPool, "Count") -- functions like a pcall
if success then
    print("Active threads:", count)
end
```
<Callout type="warning">
    ThreadStatsEnabled must be set to true in order for this function to work! Configure this in the module.
</Callout>
